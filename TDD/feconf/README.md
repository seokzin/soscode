# Keywords

## TDD Cycle

![image](https://user-images.githubusercontent.com/43740455/175890274-ec425c6d-64d5-472a-8d21-9c946706221d.png)

1. Red - 일단 만들어야 하는 코드를 작성한다.

2. Green - 최대한 빨리 (수단과 방법을 가리지 않고) 테스트를 작동할 수 있게 한다.

3. Refactor - 리팩토링한다.

## Presentational vs Container (Components)

![image](https://user-images.githubusercontent.com/43740455/175892270-26e078c0-1115-4df8-aab2-6e8d588a3c79.png)

- Container
  - Redux의 존재를 안다.
  - Redux에서 상태를 가져와 Presentational을 통해 그린다.
- Presentational
  - Redux의 존재를 모른다.

## SRP (단일 책임 원칙)

- 하나의 객체는 하나의 책임을 가진다. 즉 컴포넌트가 응집된 책임을 가지도록 설계한다. 클래스를 수정할 때 수정할 이유가 2개 이상 있으면 안 된다. 이는 하나의 클래스가 많은 기능을 가진 거나 다름없기 때문이다. 이러면 수정할 때 다른 모듈들에 어떤 영향을 끼치는지 이해하기 어려워진다.

# Insights

- 최대한 빨리, 수단과 방법을 가리지 않는다! 머릿속에 더 나은 로직이 떠오르더라도 그보다 빨리 테스트를 통과할 수 있는 로직을 작성한다. 그리고 리팩토링 사이클을 돌리면 된다. 빠른 피드백 루프가 있기 때문에 가능한 원칙

- 실제 현업에서도 브라우저의 모습을 거의 볼 필요가 없다. jest watch mode를 통해 빠르게 결과를 확인할 수 있기 때문이다.

- Redux를 왜 쓰는가?

  - 상태 관리는 당연하다.. 그보다 근본적인 답을 생각해보면 - **React의 관심사**는 상태 관리가 아닌 **상태의 반영(State Reflection)**이다. 즉 UI가 전달된 상태를 제대로 표현하는지에 관심이 있다.
  - 컴포넌트 간의 관심사의 분리를 해야 한다. 서로의 상태에 대한 관심사를 분리 시켜야 한다. 최대한 컴포넌트를 작게 만들어야 한다. 지금 이 컴포넌트가 가져야 할 관심사가 맞는지 항상 질문을 던져야 한다.

- SRP를 지키며 컴포넌트를 설계하려 노력하자. 의존성이 생기지 않는 것은 테스트를 수월하게 작성할 수 있고, 이는 곧 TDD를 수월하게 할 수 있게 만들어준다.

# Reference

- [A5] 프론트엔드에서 TDD가 가능하다는 것을 보여드립니다.
