# Ch-01. 리팩터링: 첫 번째 예시

## 👎 Why (이유, 목적)

- 코드가 너무 길어서 코드를 나눠야 한다.
- 로컬 변수가 많아서 이해나 유지보수 하기에 어렵다.
- 기능 단위로 코드를 묶어서 이름을 부여하고 싶다.

## 👨‍💻 How (행동)

- **함수 추출하기 (6-1)**

  - **코드가 하는 일**을 잘 보여줄 수 있는 함수명을 짓는다.
  - 함수를 빼냈을 때 **유효 범위를 벗어나는 변수**를 매개변수 등으로 잘 관리한다.

- **임시 변수를 질의 함수로 바꾸기 (7-4)**

  - 임시 변수(로컬 변수)는 추출 작업을 복잡하게 만들기 때문이다.

- **변수 인라인하기 (6-4)**

  - 다른 임시 변수도 질의 함수로 대체하여 최종적으로 임시 변수를 제거한다.
  - (변경되지 않는 변수들이 제거하기 용이하다.)

- **함수 선언 바꾸기 (6-5)**

  - 함수의 매개변수도 질의 함수로 대체하여 제거할 수 있다.

- **반복문 쪼개기 (8-7)**

  - 두 가지 이상의 일을 하는 반복문은 수정, 이해, 사용 면에서 모두 불편하다.

- **문장 슬라이드하기 (8-6)**

  - 관련된 코드들이 모여있으면 더욱 이해하기 쉽다.

- **단계 쪼개기 (6-11)**

  - 코드를 상태나 동작에 따라 각각의 단계로 나눈다.
  - 단일 책임 원칙을 지키게 되어 유지보수와 확장이 편하다.

- **함수 옮기기 (8-1)**

  - 함수를 더 적합한 위치로 옮기는 것이 모듈성을 높여준다.

- **반복문을 파이프라인으로 바꾸기 (8-8)**

  - 파이프라인 함수는 흐름 파악이 수월하다.
  - 주로 ES6의 배열 메서드들을 활용한다.

- **조건부 로직을 다형성으로 바꾸기 (10-4)**

  - 조건문 자체는 로직의 분기, 즉 여러 일을 하고있다는 의미다.
  - 분기별로 클래스화 한다면 다형성을 활용할 수 있다.

- **타입 코드를 서브클래스로 바꾸기 (12-6)**

  - case의 타입보다는 서브클래스가 더욱 유용하다.
  - 다형성(10-4)을 활용할 수 있는 기반을 마련하기 때문이다.

- **생성자를 팩토리 함수로 바꾸기 (11-8)**
  - 팩토리 함수를 통해 생성자의 제약들을 해결할 수 있다.

## 👍 What (결과)

- 함수 분리를 통해 계산 로직을 다 보조 함수로 빼고 메인 로직을 7줄로 줄였다!
- 그리고 분리된 함수는 의미 파악과 유지보수를 용이하게 했다.
- 로컬 변수를 최대한 제거하여서 고려해야할 대상을 줄였다.
- Q. 변수가 질의 함수로 바뀌면서 매번 함수 실행이 되니 비효율적이다.
  - A. 성능에 영향은 있지만 큰 영향은 아니다. 오히려 지역 변수를 제거하여 얻는 장점이 훨씬 크다. 스코프를 고려할 대상이 줄어들게 되면서 추출이 쉬워지기 때문이다.
- switch 등의 분기를 다형성을 활용한다면 상속, 메서드 등의 클래스 기능을 활용할 수 있다.
